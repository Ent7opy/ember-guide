# EmberGuide API

FastAPI backend that serves wildfire nowcast products (GeoTIFFs, tiles, metadata, reports) generated by the pipeline.

---

## Overview

The API provides:
- **Fire catalog**: List of active fires and their metadata
- **Nowcast data**: Probability rasters, direction, uncertainty
- **Map tiles**: PNG tiles for web map rendering (XYZ scheme)
- **Reports**: JSON summaries with metrics and caveats
- **Health checks**: System status and data freshness

**Key principles**:
- No heavy computation on request (read from pre-generated `data/products/`)
- Consistent CORS for web UI
- Timeouts ≤ 10s per request
- 4xx/5xx errors with JSON Problem Details (RFC 7807)

---

## Quick Start

### Development Server

```bash
# Activate virtual environment
source venv/bin/activate  # Windows: venv\Scripts\activate

# Install dependencies
pip install -r requirements.txt

# Run locally (hot reload)
uvicorn api.main:app --reload --port 8000

# Or use Make
make serve-api
```

Visit http://localhost:8000/docs for interactive API documentation (Swagger UI).

### Production

```bash
# Use gunicorn with uvicorn workers
gunicorn api.main:app \
  --workers 4 \
  --worker-class uvicorn.workers.UvicornWorker \
  --bind 0.0.0.0:8000 \
  --timeout 10 \
  --access-logfile -
```

See [docs/DEPLOYMENT.md](../docs/DEPLOYMENT.md) for full production setup.

---

## API Endpoints (Stable Contracts)

### `GET /health`

Health check and system status.

**Response**:
```json
{
  "status": "healthy",
  "timestamp": "2024-01-15T14:30:00Z",
  "data_freshness": {
    "firms": "2024-01-15T12:00:00Z",
    "era5": "2024-01-15T09:00:00Z"
  },
  "version": "0.1.0"
}
```

---

### `GET /fires`

List all active fires.

**Query Parameters**:
- `since` (optional): ISO 8601 timestamp — only fires detected after this time
- `region` (optional): Region code (e.g., `CA`, `CONUS`) — filter by region

**Response**:
```json
{
  "fires": [
    {
      "id": "fire_001",
      "region": "CA_north",
      "centroid": {"lat": 39.5, "lon": -121.5},
      "detections": {
        "count": 245,
        "last_time": "2024-01-15T12:30:00Z"
      },
      "bbox": [-122.5, 38.5, -121.0, 40.0],
      "status": "active",
      "nowcast_available": [12, 24, 48]
    },
    {
      "id": "fire_002",
      "region": "CO_front_range",
      "centroid": {"lat": 39.8, "lon": -105.0},
      "detections": {
        "count": 87,
        "last_time": "2024-01-14T18:00:00Z"
      },
      "bbox": [-105.5, 39.0, -104.5, 40.5],
      "status": "active",
      "nowcast_available": [24]
    }
  ],
  "count": 2,
  "generated_at": "2024-01-15T14:30:00Z"
}
```

**Status Codes**:
- `200`: Success
- `400`: Invalid query parameters
- `500`: Internal error

---

### `GET /nowcast/{fire_id}`

Get nowcast data for a specific fire.

**Path Parameters**:
- `fire_id`: Fire identifier (e.g., `fire_001`)

**Query Parameters**:
- `horizon`: `12`, `24`, or `48` (hours) — defaults to `24`

**Response**:
```json
{
  "fire_id": "fire_001",
  "horizon": 24,
  "grid_meta": {
    "center_lat": 39.5,
    "center_lon": -121.5,
    "crs": "EPSG:32610",
    "resolution_m": 1000,
    "shape": [100, 100]
  },
  "assets": {
    "prob_tif": "/downloads/fire_001/nowcast_24h.tif",
    "dir_tif": "/downloads/fire_001/direction_24h.tif",
    "uncertainty_tif": "/downloads/fire_001/uncertainty_24h.tif",
    "tile_template": "/tiles/fire_001/24h/{z}/{x}/{y}.png"
  },
  "detections": [
    {"lat": 39.45, "lon": -121.52, "time": "2024-01-15T12:00:00Z", "confidence": 95},
    {"lat": 39.48, "lon": -121.50, "time": "2024-01-15T12:00:00Z", "confidence": 90}
  ],
  "metrics": {
    "max_probability": 0.87,
    "mean_probability": 0.12,
    "affected_area_km2": 450,
    "primary_direction_deg": 245,
    "wind_speed_avg_ms": 8.5
  },
  "caveats": [
    "Weather resolution is ~25 km; local canyon winds may differ.",
    "Hotspots are coarse (~375–1000 m) and intermittent.",
    "Research preview — not for life-safety decisions."
  ],
  "generated_at": "2024-01-15T14:00:00Z"
}
```

**Status Codes**:
- `200`: Success
- `404`: Fire ID or horizon not found
- `400`: Invalid horizon value
- `500`: Internal error

---

### `GET /tiles/{fire_id}/{horizon}/{z}/{x}/{y}.png`

Map tiles for web rendering (XYZ scheme).

**Path Parameters**:
- `fire_id`: Fire identifier
- `horizon`: `12h`, `24h`, or `48h`
- `z`, `x`, `y`: Zoom level and tile coordinates (Web Mercator)

**Response**:
- `Content-Type: image/png`
- PNG image (256×256 pixels)

**Status Codes**:
- `200`: Tile found
- `404`: Tile does not exist (outside bounds or not generated)
- `500`: Internal error

**Caching**:
- Tiles are static once generated
- Set `Cache-Control: max-age=86400` (24 hours)

---

### `GET /report/{fire_id}`

JSON report with summary and metrics.

**Path Parameters**:
- `fire_id`: Fire identifier

**Query Parameters**:
- `horizon`: `12`, `24`, or `48` (defaults to `24`)

**Response**:
```json
{
  "fire_id": "fire_001",
  "region": "CA_north",
  "horizon": 24,
  "summary": {
    "detections_count": 245,
    "detections_last_time": "2024-01-15T12:30:00Z",
    "affected_area_km2": 450,
    "max_probability": 0.87,
    "primary_direction_deg": 245
  },
  "weather": {
    "wind_speed_avg_ms": 8.5,
    "wind_direction_deg": 240,
    "rh_avg_pct": 25,
    "temp_avg_c": 28
  },
  "evaluation": {
    "reliability_score": 0.82,
    "calibration_note": "Model calibrated on 2020–2023 Western US fires."
  },
  "caveats": [
    "Research preview — not for life-safety decisions.",
    "Hotspot detection has 3–6 hour lag.",
    "Weather resolution is coarse (~25 km)."
  ],
  "attribution": [
    "FIRMS (NASA): Active fire data",
    "ERA5 (Copernicus/ECMWF): Weather reanalysis",
    "SRTM (NASA/USGS): Terrain data"
  ],
  "generated_at": "2024-01-15T14:00:00Z"
}
```

**Status Codes**:
- `200`: Success
- `404`: Fire ID or horizon not found
- `500`: Internal error

---

### `GET /downloads/{fire_id}/{filename}`

Download GeoTIFF files.

**Path Parameters**:
- `fire_id`: Fire identifier
- `filename`: File name (e.g., `nowcast_24h.tif`)

**Response**:
- `Content-Type: image/tiff` (or `application/geo+json` for metadata)
- File download

**Status Codes**:
- `200`: File found
- `404`: File does not exist
- `500`: Internal error

---

### `GET /openapi.json`

OpenAPI 3.0 schema (auto-generated by FastAPI).

Visit `/docs` for Swagger UI or `/redoc` for ReDoc.

---

## Schemas (Contracts)

All schemas are defined in `api/contracts.py` using Pydantic models.

### Example: Fire Schema

```python
from pydantic import BaseModel, Field
from datetime import datetime

class FireDetections(BaseModel):
    count: int = Field(..., description="Number of hotspot detections")
    last_time: datetime = Field(..., description="Most recent detection timestamp")

class Fire(BaseModel):
    id: str = Field(..., description="Unique fire identifier")
    region: str = Field(..., description="Region code or name")
    centroid: dict[str, float] = Field(..., description="Lat/lon of fire center")
    detections: FireDetections
    bbox: list[float] = Field(..., description="[west, south, east, north]")
    status: str = Field(..., description="active | contained | out")
    nowcast_available: list[int] = Field(..., description="Available horizons (hours)")
```

**Validation**:
- Pydantic validates all inputs/outputs
- Type mismatches return `422 Unprocessable Entity`

---

## Implementation Notes

### No Heavy Compute

The API **reads** from `data/products/`; it does **not** run the pipeline.

- Pipeline generates products offline (cron job or triggered by data updates)
- API serves static files + metadata from JSON/GeoTIFF

### CORS Configuration

Enable CORS for web UI (e.g., Streamlit on different port):

```python
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:8501"],  # Streamlit UI
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

In production, restrict to specific domains.

### Timeouts

All requests should complete within 10 seconds:
- Use async I/O for file reads
- Cache frequently accessed metadata in memory (e.g., `index.json`)
- Return `504 Gateway Timeout` if external dependencies (e.g., tile generation) hang

### Error Handling (RFC 7807)

Return structured error responses:

```python
from fastapi import HTTPException

@app.get("/nowcast/{fire_id}")
async def get_nowcast(fire_id: str, horizon: int = 24):
    if fire_id not in fire_catalog:
        raise HTTPException(
            status_code=404,
            detail={
                "type": "https://emberguide.dev/errors/fire-not-found",
                "title": "Fire Not Found",
                "status": 404,
                "detail": f"Fire {fire_id} does not exist.",
                "instance": f"/nowcast/{fire_id}"
            }
        )
    # ... normal processing
```

---

## Testing

### Endpoint Golden Tests

Use snapshot files to verify exact responses:

```python
import pytest
from fastapi.testclient import TestClient
from api.main import app

client = TestClient(app)

def test_fires_endpoint():
    response = client.get("/fires")
    assert response.status_code == 200
    data = response.json()
    assert "fires" in data
    assert data["count"] >= 0

def test_nowcast_endpoint():
    response = client.get("/nowcast/fire_001?horizon=24")
    assert response.status_code == 200
    data = response.json()
    assert data["fire_id"] == "fire_001"
    assert data["horizon"] == 24
    assert "assets" in data
```

### Snapshot Testing

For stable outputs, compare against golden JSON:

```python
import json

def test_fires_snapshot():
    response = client.get("/fires")
    expected = json.load(open("tests/fixtures/fires_snapshot.json"))
    assert response.json() == expected  # Exact match
```

### Testing with Mock Data

Create a test `data/products/` structure:

```
tests/fixtures/products/
├── index.json
└── fire_test/
    ├── metadata.json
    ├── nowcast_24h.tif
    └── tiles/24h/{z}/{x}/{y}.png
```

Override data path in tests:

```python
import os
os.environ["PRODUCTS_DIR"] = "tests/fixtures/products"
```

---

## Configuration

### Environment Variables

```bash
# Data paths
PRODUCTS_DIR=data/products
RAW_DATA_DIR=data/raw

# Server
API_HOST=0.0.0.0
API_PORT=8000
API_WORKERS=4

# Logging
LOG_LEVEL=INFO
LOG_FORMAT=json  # or 'text' for development

# CORS (production)
CORS_ORIGINS=https://emberguide.example.com,https://map.emberguide.example.com
```

### Config File (Optional)

For more complex setups, use `configs/api.yml`:

```yaml
server:
  host: 0.0.0.0
  port: 8000
  workers: 4
  timeout: 10

data:
  products_dir: data/products
  cache_ttl: 300  # seconds

cors:
  origins:
    - http://localhost:8501
    - https://emberguide.example.com
```

---

## Monitoring & Logging

### Structured Logging

Use JSON logs for production:

```python
import logging
import json

logger = logging.getLogger("api")

@app.get("/nowcast/{fire_id}")
async def get_nowcast(fire_id: str):
    logger.info(json.dumps({
        "event": "nowcast_request",
        "fire_id": fire_id,
        "timestamp": datetime.utcnow().isoformat()
    }))
    # ... handle request
```

### Metrics

Track with Prometheus or custom middleware:
- Request count by endpoint
- Response time (p50, p95, p99)
- Error rate (4xx, 5xx)
- Cache hit rate

Example Prometheus metrics:
```python
from prometheus_client import Counter, Histogram

request_count = Counter("api_requests_total", "Total requests", ["endpoint", "status"])
request_duration = Histogram("api_request_duration_seconds", "Request duration", ["endpoint"])
```

---

## Performance Optimization

### Caching

1. **In-memory cache** for `index.json` and fire metadata
2. **HTTP caching** for tiles (set `Cache-Control` headers)
3. **CDN** for tiles in production (CloudFront, Cloudflare)

Example caching middleware:
```python
from fastapi import Response
from datetime import timedelta

@app.get("/tiles/{fire_id}/{horizon}/{z}/{x}/{y}.png")
async def get_tile(fire_id: str, horizon: str, z: int, x: int, y: int):
    # ... serve tile
    return Response(
        content=tile_bytes,
        media_type="image/png",
        headers={"Cache-Control": "public, max-age=86400"}
    )
```

### Async I/O

Use async file reads for large files:

```python
import aiofiles

@app.get("/downloads/{fire_id}/{filename}")
async def download_file(fire_id: str, filename: str):
    path = f"data/products/{fire_id}/{filename}"
    async with aiofiles.open(path, "rb") as f:
        content = await f.read()
    return Response(content=content, media_type="image/tiff")
```

---

## Security

### Authentication (Optional)

For production, consider API keys or OAuth:

```python
from fastapi import Security, HTTPException
from fastapi.security.api_key import APIKeyHeader

api_key_header = APIKeyHeader(name="X-API-Key")

def verify_api_key(api_key: str = Security(api_key_header)):
    if api_key != os.getenv("API_KEY"):
        raise HTTPException(status_code=403, detail="Invalid API key")
    return api_key
```

### Rate Limiting

Use `slowapi` or reverse proxy (nginx):

```python
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address

limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter
app.add_exception_handler(429, _rate_limit_exceeded_handler)

@app.get("/fires")
@limiter.limit("60/minute")
async def list_fires(request: Request):
    # ... handle request
```

---

## Deployment

See [docs/DEPLOYMENT.md](../docs/DEPLOYMENT.md) for:
- Docker containerization
- Reverse proxy (nginx) configuration
- SSL/TLS setup
- Monitoring and alerting

---

## Troubleshooting

### "404 Not Found" for valid fire ID

**Solution**:
- Check `data/products/index.json` — is fire listed?
- Verify `PRODUCTS_DIR` env var points to correct path
- Ensure pipeline completed successfully (check logs)

### "500 Internal Server Error"

**Solution**:
- Check API logs for stack trace
- Verify file permissions on `data/products/`
- Test with `make eval` to isolate pipeline vs API issues

### Slow tile responses

**Solution**:
- Pre-generate all tiles (run `make tiles`)
- Enable CDN or reverse proxy caching
- Check disk I/O (use SSD for `data/products/`)

---

## Next Steps

- **UI Integration**: See [ui/README.md](../ui/README.md) for Streamlit frontend
- **Pipeline**: See [pipeline/README.md](../pipeline/README.md) for data generation
- **Deployment**: See [docs/DEPLOYMENT.md](../docs/DEPLOYMENT.md) for production setup

---

## References

- [FastAPI Documentation](https://fastapi.tiangolo.com/)
- [OpenAPI 3.0 Spec](https://swagger.io/specification/)
- [RFC 7807: Problem Details](https://tools.ietf.org/html/rfc7807)
- [WILDFIRE_101.md](../WILDFIRE_101.md) — Domain concepts

